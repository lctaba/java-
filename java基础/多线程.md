## 多个不同的代码块（方法）获取了同一个锁，那么他们都是互斥的。



## Thread常用方法

- sleep()：休眠，交出当前CPU权限。与yield不同，sleep(0)会让位给高优先级的线程
- yield()：会让线程交出当前CPU权限，同样不会释放锁，并且不能控制交出CPU的具体时间，同时只能让有相同优先级的线程获取CPU执行的机会。不会让线程进入阻塞态，而是回到就绪态
- join()：其他所有线程等待当前线程执行完毕再继续执行。在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。
- start()：启动线程，将线程转为就绪态
- resume()：用于唤醒resume挂起的线程
- interrupt()：使处于阻塞状态的线程抛出异常，用于中断线程
- wait()：object的方法：使当前线程等待，直到被notify和notifyAll唤醒，会释放锁对象
- notify()：object的方法：唤醒一个wait的线程，唤醒哪个由线程管理决定
- notifyAll()：object的方法：唤醒所有wait线程
- isAlive()：判断线程是不是已经start（）并且没有dead，包括阻塞态。
- currentThread()：获得当前线程
- setPriority(int newPriority)： 设置优先级
- suspend()： 用于挂起线程，需要resume唤醒（不会释放锁）

sleep()不会释放锁，sleep(0)用于重新让线程竞争cpu资源

new Thread(Runnable target, String name)



## 线程的状态

创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）。

创建后不会马上进入就绪，还要分配内存，如程序计数器，栈，方法栈。start（）之后才进入就绪



## 线程的上下文切换

对于线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。





## CAS

为什么要用乐观锁？

因为加了悲观锁之后获取不到资源的线程会阻塞，获取到资源后再转为运行态，涉及到用户态和内核态的转换，开销比较高。

CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。

如果再比较的时候内存的值被修改了，那么他会重新尝试原来的操作。重新尝试被称为自旋。

CAS的缺点：

1.CPU开销较大
 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。

2.不能保证代码块的原子性
 CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。



**自旋锁（spinlock）**：

是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

#### 锁粗化

一个循环总频繁拿锁开销很大，所以将锁加到循环外面。

#### 缩消除

去掉没必要的加锁

#### 偏向锁

解决每次都是一个线程获得锁。

就是每次都是同一个人去找管理员要钥匙，到最后管理员说钥匙你直接拿把不用登记了。

当一个进程访问的时候，就在锁对象的对象头里记录获取锁的进程id。

下次用的时候就检查，是不是这个线程，是就直接进去，

如果不是那么就要检查偏向锁标志位，如果是1，那么说明还是偏向锁，不过不是同一个线程了

然后当前线程cas获取锁，如果获得了，说明竞争成功，那么就将偏向锁的线程id改为新线程，新线程直接进入操作。

如果cas竞争失败，说明当前其他进程也在使用该锁，则将偏向锁升级为轻量级锁。

如果是0，说明已经发生了竞争，不是偏向锁了





#### 轻量级锁

要获得锁的时候，利用cas将对象的mark word复制到线程栈帧中，然后用cas将对象的markword变为指向栈帧中复制的指针。

如果cas失败，锁自旋，自旋失败，升级为重量级锁。

同步代码执行完毕后，利用cas将栈帧中的markword复制到对象中。如果此时锁已经升级为重量级锁，那么就释放锁并唤醒等待的线程。

![img](https://img-blog.csdnimg.cn/20190217203239663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9fbWlhbw==,size_16,color_FFFFFF,t_70)



#### 重量级锁

当要获取的锁被持有时，当前线程阻塞