### 回收的对象：

只回收堆区和方法区，栈区会自动释放。



### 如何判断对象可以回收：

- 对象没有引用了
- 程序在作用域正常执行完毕
- 作用域发生未捕获异常
- 程序执行了System.exit()
- 程序意外终止



### 什么时候执行：

eden区空间不够存放新对象的时候，执行Minro GC。升到老年代的对象大于老年代剩余空间的时候执行Full GC，或者小于的时候被**HandlePromotionFailure** 参数强制Full GC 。调优主要是减少 Full GC 的触发次数，可以通过 **NewRatio** 控制新生代转老年代的比例，通过**MaxTenuringThreshold** 设置对象进入老年代的年龄阀值（后面会介绍到）。



### 按代回收

#### 新生代

新创建的对象一般都在此，大部分创建后就很快不可达，从这个区域清除成为Minor GC。

##### 空间构成逻辑

- 一个伊甸园空间（Eden）

- 两个幸存者空间（Fron Survivor、To Survivor）

默认8：1：1

新创建的对象放在Eden，执行一次GC后仍然存活就将其移动到一个Survivor中，这时所有存活的对象都移动到一个Survivor中。当Survivor饱和时，将还存活的对象移动到另一个Survivor中，并将饱和的Survivor清空。

上述步骤执行N次后仍然存活的对象（N默认15），就移动到老年代。

如果有需要分配连续的较大的空间对象，Survivor无法存放就直接进入老年代

#### 老年代

对象没有变得不可达，并且从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的GC次数要比新生代少得多。对象从老年代中消失的过程，称之为：**Major GC** 或者 **Full GC。**

##### card table

记录老年代对象对新生代对象的引用，用于判断新生代是否可达，而不用查询整个老年代，用于对新生代的回收。

#### 持久代（方法区）

用于保存类常量以及字符串常量。注意，这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为 Major GC 。只不过在这个区域发生GC的条件非常严苛，必须符合以下三种条件才会被回收

- 所有实例被回收

- 加载该类的ClassLoader 被回收

- Class 对象无法通过任何途径访问（包括反射）

#### 方法区

- 用于保存被加载过的每一个类的信息。这些信息在类加载器加载类的时候，从源文件中抽取出来，static变量也保存在方法区。
  - 包括类型信息，全限定类名，父类名，接口列表，类的修饰符
  - 类型常量池（运行时常量池）
    - 类型常量池存放着编译时期生成的各种字面值和符号引用，字面值指的是在编译期间就可以确定下来的值，如final变量，基本数据类型。在类加载的时候复制到方法区中。
  - 类的字段信息
  - 类的方法信息
  - 类变量static变量
  - 对类加载器的引用
  - 对class类的引用
- jdk1.8以后将class对象，静态变量，常量池放入了堆中，类的信息被放入元空间中

### GC算法

#### 引用计数

无法解决循环引用的问题。

高并发状态下可能导致计数出错。

#### 根搜索算法

从一些GC Root节点出发，所有不可达的节点就被回收。

目前Java中可以作为GC ROOT的对象有：

1、虚拟机栈中引用的对象（本地变量表）（还在等待执行的对象）

2、方法区中静态属性引用的对象

3、方法区中常量引用的对象

4、本地方法栈中引用的对象（Native对象）

#### 三色标记

如果只是单纯标记是否可达，在并发状态下可能会出现新添加的引用被清除的情况。于是引入了三色标记。

用一种颜色标记已经检查过而且其下属对象全部检查过的对象。

用另一种颜色标记该对象已经被标记过了，但该对象下的属性没有全被标记完。

没有被标记过的对象就是最后一种颜色。

如果在并发过程中一个白色对象被者黑色对象引用了，那么就将黑色对象标为灰色，表明该对象还没有扫描完。

#### 标记清除算法（适用存活对象较多）

将不可达的对象标记然后直接清楚，但这会导致内存碎片

#### 复制算法（使用存活率低），因此多用于新生代

将内存分区，分为空闲区与活动区

所有的对象都存在活动区中，当GC时，扫描活动区，将存活的对象复制放入空闲区中，其余的清除。

#### 标记 - 整理算法（相比标记清除算法复杂，但是解决了内存碎片），因此多用于老年代

将所有不可达的对象清除，然后将所有还存活的对象合并到一块（左移）